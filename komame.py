# -*- coding: utf-8 -*-import osimport numpy as npimport timeimport urllibfrom flask import Flaskapp = Flask(__name__)from flask import request, abortfrom linebot import  LineBotApi, WebhookHandlerfrom linebot.exceptions import InvalidSignatureErrorfrom linebot.models import MessageEvent, TextMessage, TextSendMessage, AudioSendMessagefrom src.db_operation import *DATABASE = 'komame_bot'BOT = 'komame-bot'#資料從資料庫取得lbdp = Line_bot_db_parser(DATABASE)#設置 API 用來串接服務LINE_API = LineBotApi(lbdp.get_channel_access_token(BOT))#設置 handler 用來應對客戶端要求HANDLER = WebhookHandler(lbdp.get_channel_secret(BOT))#取得 webhook 網域名稱 WEBHOOK_DNS = lbdp.get_webhook_dns(BOT)#設置 flask static 路徑STATIC_MP3_PATH = "https://{}/static/mp3".format(WEBHOOK_DNS)#取得關鍵字列表#關鍵字去比對回應有沒有符合的#列出符合的關鍵字#關鍵字查表查字組群組#隨機取一個字組回應@app.route("/")def test():    return "test connect"@app.route("/callback", methods=['POST'])def callback():    signature = request.headers['X-Line-Signature']    body = request.get_data(as_text=True)    try:        HANDLER.handle(body, signature)    except InvalidSignatureError:        abort(400)    return 'OK'#定義如何處理訊息@HANDLER.add(MessageEvent, message=TextMessage)def handle_message(event):    #取得使用者的文字訊息    mtext = event.message.text.strip()    print(mtext)    #回傳音訊    play_audio(event.reply_token, mtext)METHODS={}def play_audio(token, mtext):    mp3_path = ""    if mtext == "/help":        cmd_list=""        for key in METHODS.keys():            cmd_list += key + "\n"        msg = TextSendMessage(cmd_list)        LINE_API.reply_message(token, msg)        return        replay = False    message = []    for key in METHODS.keys():        if key in mtext:            mp3_path_list = METHODS[key]            rng = int(np.random.rand() * 100)            index = rng % len(mp3_path_list)            mp3_path = mp3_path_list[index]            print(mp3_path)            audio_msg = AudioSendMessage(original_content_url = mp3_path, duration=20000)            message.append(audio_msg)            replay = True        if not replay:        message.append(TextSendMessage("hello"))        LINE_API.reply_message(token, message)    def load_method():    for root, dirs, files in os.walk(os.path.join("./static/mp3")):        basename = os.path.basename(root)        if basename == "bad":            continue                    for filename in files:            if ".mp3" in filename:                if basename not in METHODS:                    METHODS[basename] = []                url = STATIC_MP3_PATH + "/" + urllib.parse.quote(basename + "/" + filename)                METHODS[basename].append(url)                print(url)if __name__ == '__main__':    load_method()    app.run()